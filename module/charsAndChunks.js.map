{"version":3,"file":"charsAndChunks.js","sources":["../src/collectionManagement.js","../src/index.js","../src/charsAndChunks.js"],"sourcesContent":["const collectionManagement = (function() {\n  /**\n   * Map of contexts holding an object with a single charcter, a callback and optionally a comment\n   */\n  let references = new WeakMap()\n  /**\n   * Map of characters and regular expressions holding a context.\n   */\n  let requests = new Map()\n  /**\n   * Default regular expression.\n   */\n  const catchAllRegExp = /^/\n\n  const isSaneRegistration = function(props) {\n    const matchOK = (function() {\n      if (props.char) {\n        return typeof props.char === 'string' && props.char.length === 1\n      } else if (props.regex) {\n        return props.regex instanceof RegExp\n      }\n    })()\n    const contextOK = props.context instanceof Node\n    const callbackOK = typeof props.callback === 'function'\n    // check optional comment\n    if (!props.comment) {\n      props.comment = `callback for ${props.char || 'barcode'}`\n    }\n    const OK = matchOK && contextOK && callbackOK\n    if (!OK) {\n      console.error('Wrong properties for registering hotkeys or barcodes!')\n    }\n    return OK\n  }\n\n  /**\n   * Register a context to trigger a function when the character is pressed\n   * @param {string} character - single character\n   * @param {object} context - Node\n   * @param {function} callback\n   * @param {string} comment (optional)\n   */\n  const registerHotkey = function(props) {\n    delete props.regex\n    if (!isSaneRegistration(props)) {\n      return\n    }\n\n    // Register context with character in a Map\n    requests.set(props.char, props.context)\n    if (!references.has(props.context)) {\n      references.set(props.context, {})\n    }\n    // Register data with context in a WeakMap\n    references.get(props.context)[props.char] = {\n      callback: props.callback,\n      comment: props.comment,\n    }\n    //console.log(`hotkey registered: ${props.char}`)\n  }\n\n  /**\n   * Get valid data\n   * @private\n   * @param {Node} context\n   * @param {string | RegExp} entry\n   * @returns {object} data object\n   */\n  const getHandle = function(context, entry) {\n    if (context && context.parentNode && references.has(context)) {\n      return references.get(context)[entry]\n    }\n    // should we garbage collect programatically?\n  }\n\n  /**\n   * Find the right data\n   * @private\n   * @param {string | RegExp} entry\n   * @returns {object} data object\n   */\n  const entryHandler = function(entry) {\n    if (requests.has(entry)) {\n      let requestedContext = requests.get(entry)\n      return getHandle(requestedContext, entry)\n    }\n  }\n\n  /**\n   * Register a context to trigger a function when any barcode is encountered\n   * @param {object} context - Node\n   * @param {function} callback\n   * @param {string} comment (optional)\n   */\n  const registerBarcode = function(props) {\n    delete props.char\n    if (!props.regex) {\n      props.regex = catchAllRegExp\n    }\n    if (!isSaneRegistration(props)) {\n      return\n    }\n\n    // Register context with regular expression in a Map\n    requests.set(props.regex, props.context)\n    if (!references.has(props.context)) {\n      references.set(props.context, {})\n    }\n    // Register data with context in a WeakMap\n    references.get(props.context)[props.regex] = {\n      callback: props.callback,\n      comment: props.comment,\n    }\n    //console.log(`barcode registered: ${props.regex}`)\n  }\n\n  /**\n   * Find the right RegExp for barcode\n   * @private\n   * @param {string} barcode\n   * @returns {RegExp}\n   */\n  const barcodeMatch = function(barcode) {\n    var regex = catchAllRegExp\n\n    requests.forEach((reqValue, reqKey) => {\n      if (reqKey instanceof RegExp && reqKey.test(barcode)) {\n        // find the most complex RegExp\n        if (reqKey.toString().length > regex.toString().length) {\n          regex = reqKey\n        }\n      }\n    })\n    return regex\n  }\n\n  /**\n   * Find the right data\n   * @private\n   * @param {string} barcode\n   * @returns {object} data object\n   */\n  const barcodeHandler = function(barcode) {\n    const regex = barcodeMatch(barcode)\n    return entryHandler(regex)\n  }\n\n  /**\n   * Generate a list of active hotkeys and barcode watchers, optionally with their purpose\n   * @returns {object}\n   */\n  const overview = function() {\n    //console.log('overview called')\n    let handles = { hotkey: [], barcode: [] }\n\n    requests.forEach((context, entry) => {\n      if (typeof entry === 'string') {\n        let handle = getHandle(context, entry)\n        if (handle) {\n          let toEndUser = {\n            entry: entry,\n            comment: handle.comment,\n          }\n          handles.hotkey.push(toEndUser)\n        }\n      }\n    })\n\n    requests.forEach((context, entry) => {\n      if (entry instanceof RegExp) {\n        let handle = getHandle(context, entry)\n        if (handle) {\n          let toEndUser = {\n            entry: 'barcode', //entry.toString(),\n            comment: getHandle(context, entry).comment,\n          }\n          handles.barcode.push(toEndUser)\n        }\n      }\n    })\n    //console.log(handles)\n    return handles\n  }\n\n  return {\n    registerHotkey: registerHotkey,\n    hotkeyHandler: entryHandler,\n    registerBarcode: registerBarcode,\n    barcodeHandler: barcodeHandler,\n    overview: overview,\n  }\n})()\n\nexport { collectionManagement }\n","import { charsAndChunks } from './charsAndChunks'\n\nconst index = charsAndChunks\n\nexport default index\n","import { collectionManagement } from './collectionManagement'\n\nconst charsAndChunksModule = (function() {\n  // Maximum time the barcode scanner takes to send the next character\n  let safeIntermission = 30\n  // General treshold to prevent accidental elbow-on-keyboard processing\n  let minimalBarcodeLength = 6\n  const allowedModifiers = ['Alt', 'Shift']\n  // Process variables\n  let streamTimeout = 0\n  let stream = ''\n\n  const settleStream = function() {\n    // We only deal with single characters or barcodes.\n    if (stream.length >= minimalBarcodeLength) {\n      //console.log(`handle as barcode: ${stream} (${stream.length})`)\n      let handle = collectionManagement.barcodeHandler(stream)\n      if (handle) {\n        handle.callback(stream)\n      }\n    } else if (stream.length === 1) {\n      //console.log(`handle as character: ${stream} (${stream.length})`)\n      let handle = collectionManagement.hotkeyHandler(stream)\n      if (handle) {\n        handle.callback(stream)\n      }\n    } else {\n      //console.log(`invalid stream length: ${stream.length} (${stream})`)\n    }\n    stream = ''\n  }\n\n  const streamHandler = function(event) {\n    //console.log(`input: ${event.key}`)\n    if (streamTimeout) {\n      clearTimeout(streamTimeout)\n    }\n\n    // We expect our barcode scanner to send character by character.\n    let charByChar = event.key.length === 1\n    // We expect our input can safely be processed; we leave entry with on-the-fly editing to form controls\n    let fromFormControl =\n      event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA'\n    let notOurScope = !charByChar || fromFormControl\n\n    if (notOurScope) {\n      //console.log(`out of scope: '${event.key}' in stream: '${stream}'`)\n      if (event.key === 'Enter') {\n        // Do not wait for new characters\n        settleStream()\n        return\n      } else if (!allowedModifiers.includes(event.key)) {\n        clearTimeout(streamTimeout)\n        stream = ''\n        return\n      }\n      // With allowedModifiers we want to set a new timeout\n    } else {\n      stream += event.key\n    }\n\n    streamTimeout = setTimeout(settleStream, safeIntermission)\n  }\n\n  window.addEventListener('keydown', streamHandler)\n\n  return {\n    publicAPI: {\n      hotkey: collectionManagement.registerHotkey,\n      barcode: collectionManagement.registerBarcode,\n      overview: collectionManagement.overview,\n    },\n    testAPI: {\n      hotkeyHandler: collectionManagement.hotkeyHandler,\n      barcodeHandler: collectionManagement.barcodeHandler,\n    },\n  }\n})()\n\nconst charsAndChunks = charsAndChunksModule.publicAPI\nconst charsAndTests = charsAndChunksModule.testAPI\n\nexport { charsAndChunks, charsAndTests }\n"],"names":["collectionManagement","references","WeakMap","requests","Map","catchAllRegExp","isSaneRegistration","props","matchOK","char","length","regex","RegExp","contextOK","context","Node","callbackOK","callback","comment","OK","console","error","getHandle","entry","parentNode","has","get","entryHandler","requestedContext","registerHotkey","set","hotkeyHandler","registerBarcode","barcodeHandler","barcode","forEach","reqValue","reqKey","test","toString","barcodeMatch","overview","handles","hotkey","handle","toEndUser","push","index","allowedModifiers","streamTimeout","stream","settleStream","window","addEventListener","event","clearTimeout","charByChar","key","fromFormControl","target","tagName","includes","setTimeout","publicAPI","testAPI"],"mappings":"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"}