{"version":3,"file":"charsAndChunks.js","sources":["../src/dataLockBox.js","../src/collectionManagement.js","../src/configuration.js","../src/charsAndChunks.js","../src/index.js"],"sourcesContent":["const dataLockBox = (function() {\n  /**\n   * Definition of storage structure\n   * @member {Map} lock - Characters or RegExp's holding one context.\n   * @member {WeakMap} box - Contexts holding a object with details by character.\n   */\n  const LockBoxModel = function() {\n    this.lock = new Map()\n    this.box = new WeakMap()\n  }\n\n  let data = new LockBoxModel()\n\n  let stash = []\n\n  /**\n   * Sanity check for storage\n   * @private\n   * @returns {boolean} is sane\n   */\n  const storageSanity = function(props) {\n    const OK = typeof props.context === 'object'\n    if (!OK) {\n      console.error('Cannot store')\n    }\n    return OK\n  }\n\n  /**\n   * Store a user match and a context as lock\n   * and a context as a box with matches holding data\n   * @private\n   * @param {object} props\n   *    @member {String | RegExp} match\n   *    @member {Object} context\n   *    @member {Function} callback\n   *    @member {String} description\n   * @param {Object} box - the data itself\n   *    @member {Function} callback\n   *    @member {String} description\n   */\n  const store = function(props, box) {\n    // console.log(`match to write: ${props.match}`)\n    if (!storageSanity(props)) return\n    // Register context with string or regular expression in a Map\n    data.lock.set(props.match, props.context)\n    // console.log(`context written: ${data.lock.get(props.match)}`)\n    if (!data.box.has(props.context)) {\n      data.box.set(props.context, {})\n    }\n    // console.log(`box to write: ${data.box.get(props.context)}`)\n    // Register data with context in a WeakMap\n    data.box.get(props.context)[props.match] = box\n    // console.log(`box written: ${data.box.get(props.context)}`)\n  }\n\n  /**\n   * Find the right data for entry\n   * @param {object} props\n   *   @member {string} match - key for the lock map\n   * @returns {object} stored data object\n   */\n  const retrieve = function(props) {\n    // console.log(`entry to handle: ${props.entry}`)\n\n    if (data.lock.has(props.entry)) {\n      // find context from lock,\n      let context = data.lock.get(props.entry)\n      // console.log('context to handle:', context)\n      if (context && data.box.has(context)) {\n        const box = data.box.get(context)[props.entry]\n        // console.log('box to handle:', box)\n        return box && !box.mute ? box : undefined\n      }\n    }\n  }\n\n  /**\n   * Generate a list of active matches (those with a not-cleaned-up context)\n   * @returns {Array} records\n   */\n  const overview = function() {\n    let records = []\n    const keys = data.lock.keys()\n\n    for (let key of keys) {\n      let box = retrieve({ entry: key })\n      if (data.lock.get(key)) {\n        let record = { match: key, box: box }\n        records.push(record)\n      }\n    }\n    //console.log('overview' + JSON.stringify(records))\n    return records\n  }\n\n  /**\n   * Clear all matches and data\n   */\n  const reset = function() {\n    data = new LockBoxModel()\n  }\n\n  /**\n   * Temporary suppress or release a match\n   * @this {...(String | RegExp)} entries\n   * @param {Boolean} toggle - mute or free\n   */\n  const mute = function(toggle) {\n    const entries = this.length ? Array.from(this).flat() : data.lock.keys()\n    for (const entry of entries) {\n      if (data.lock.has(entry)) {\n        const context = data.lock.get(entry)\n        if (context && data.box.has(context)) {\n          const box = data.box.get(context)[entry]\n          box.mute = toggle\n        }\n      }\n    }\n  }\n\n  /*\n   * Disable all current data en put up a clean storage\n   */\n  const overlay = function() {\n    stash.push(Object.assign({}, data))\n    reset()\n    //console.log(`go to stack level ${stash.length}`)\n  }\n\n  /*\n   * Remove the superseded data and enable the previous data\n   */\n  const revive = function() {\n    if (stash.length) {\n      //console.log(`remove stack level ${stash.length}`)\n      data = stash.pop()\n    }\n  }\n\n  /*\n   * Remove references to contexts\n   * @param {object} context\n   */\n  const cleanup = function(context) {\n    // console.log('cleanup context', context)\n    data.lock.forEach((matchyVal, match) => {\n      // console.log('cleanup locks', matchyVal, match)\n      if (data.lock.get(match) === context) {\n        // console.log('cleanup REMOVE', data.box.get(context)[match])\n        data.lock.delete(match)\n      }\n    })\n    data.box.delete(context)\n  }\n\n  return {\n    store: store,\n    retrieve: retrieve,\n    keys: function() {\n      return data.lock.keys()\n    },\n    overview: overview,\n    reset: reset,\n    mute: function() {\n      mute.call(arguments, true)\n    },\n    free: function() {\n      mute.call(arguments, false)\n    },\n    overlay: overlay,\n    revive: revive,\n    cleanup: cleanup,\n  }\n})()\n\nexport { dataLockBox }\n","import { dataLockBox } from './dataLockBox'\n\nconst collectionManagement = (function() {\n  /**\n   * Check sanity of a registration object\n   * @private\n   * @param {object} props\n   * @returns {boolean}\n   */\n  const registrationSanity = function(props) {\n    const matchOK =\n      props.match &&\n      props.match.toString().length &&\n      (typeof props.match === 'string' || props.match instanceof RegExp)\n    const contextOK = (function() {\n      if (typeof props.context === 'string') {\n        props.context = document.querySelector(props.context)\n      }\n      return props.context && typeof props.context === 'object'\n      //props.context instanceof Node\n    })()\n    const callbackOK = typeof props.callback === 'function'\n    const descriptionOK =\n      typeof props.description === 'string' && props.description.length\n    const OK = matchOK && contextOK && callbackOK && descriptionOK\n\n    // if (!OK) {\n    //   console.log(`!OK ${JSON.stringify(props)}`)\n    //   console.log(`\n    //     matchOK: ${matchOK}, contextOK: ${contextOK},\n    //     callbackOK: ${callbackOK}, descriptionOK: ${descriptionOK}\n    //   `)\n    // }\n    return OK\n  }\n\n  /**\n   * Register a context to trigger a function when any barcode is encountered\n   * @private\n   * @param {object} props\n   *    @member {String | RegExp} match\n   *    @member {Object} context - Node\n   *    @member {Function} callback\n   *    @member {String} description\n   */\n  const registerMatch = function(props) {\n    const internals = {\n      callback: props.callback,\n      description: props.description,\n    }\n    dataLockBox.store(props, internals)\n  }\n\n  /**\n   * Register a context to trigger a function when the character is pressed\n   * @param {object} props\n   * @param {object} context - only required for resursive calls\n   */\n  const register = function(\n    props,\n    context = {\n      time: Date.now(),\n      random: Math.floor(Math.random() * Math.floor(99999)),\n    },\n  ) {\n    if (props instanceof Array) {\n      // bulk registration\n      props.forEach(matchProps => {\n        register(matchProps, context)\n      })\n    } else {\n      props.context = context\n\n      // object registration\n      if (props.match instanceof Array) {\n        // multiple match registration\n        props.match.forEach(matchItem => {\n          const matchProps = {\n            ...props,\n            match: matchItem,\n          }\n          register(matchProps, context)\n        })\n      } else {\n        // simple flow\n        if (registrationSanity(props)) {\n          registerMatch(props)\n        }\n      }\n    }\n\n    // return a cleanup function\n    const cleanUpFn = function() {\n      dataLockBox.cleanup(context)\n    }\n    return cleanUpFn\n  }\n\n  /**\n   * Find the right data for hotkey\n   * @param {string} match\n   * @returns {object} data object\n   */\n  const hotkeyHandler = function(char) {\n    // console.log('hotkeyHandler ' + char)\n    if (char === '?') {\n      toggleOverviewPanel()\n    } else {\n      let handle = dataLockBox.retrieve({ entry: char })\n      if (!handle) {\n        const records = dataLockBox.overview()\n        records.some(record => {\n          if (record.match instanceof Array && record.match.includes(char)) {\n            handle = dataLockBox.retrieve({ entry: record.match })\n            // console.log(`handle found: ${handle.description}`)\n          }\n          return Boolean(handle)\n        })\n      }\n      return handle\n    }\n  }\n\n  /**\n   * Find the lengthiest RegExp for barcode\n   * @private\n   * @param {string} barcode\n   * @returns {RegExp}\n   */\n  const barcodeMatch = function(barcode) {\n    let regex = ''\n    const keys = dataLockBox.keys()\n\n    for (let key of keys) {\n      // console.log('examine regex:', key)\n      if (key instanceof RegExp && key.test(barcode)) {\n        // find the most complex RegExp\n        if (key.toString().length > regex.toString().length) {\n          regex = key\n        }\n        // console.log('matched regex:', key, ', pick:', regex)\n      }\n    }\n    // console.log(`barcodeMatch: ${regex}`)\n    return regex\n  }\n\n  /**\n   * Find the right data for barcode\n   * @param {string} barcode\n   * @returns {object} data object\n   */\n  const barcodeHandler = function(barcode) {\n    // console.log('barcodeHandler barcode', barcode)\n    const pattern = barcodeMatch(barcode)\n    // console.log('barcodeHandler pattern', pattern)\n    const retrieved = dataLockBox.retrieve({ entry: pattern })\n    // console.log('barcodeHandler retrieved ', retrieved)\n    return retrieved\n  }\n\n  /**\n   * Generate a list of active entries\n   * @returns {object}\n   */\n  const overviewJson = function() {\n    let records = dataLockBox.overview()\n\n    // look for multiMatches\n    let matchRecords = new Object()\n    records.forEach(record => {\n      var peers = records.filter(\n        other =>\n          other.box &&\n          record.box &&\n          other.box.callback === record.box.callback &&\n          other.box.description === record.box.description,\n      )\n      if (peers.length > 1) {\n        var matches = peers.map(peer => peer.match)\n        matchRecords[matches] = 'box'\n      }\n    })\n\n    // add multiMatches as one record, remove seperate records\n    const multiMatches = Object.keys(matchRecords)\n    multiMatches.forEach(multiMatch => {\n      const multiMatchArray = multiMatch.split(',')\n      multiMatchArray.forEach((matchItem, matchIndex) => {\n        records = records.map(record => {\n          if (record && record.match === matchItem) {\n            if (!matchIndex) {\n              // replace first matchItem\n              record = {\n                ...record,\n                match: multiMatch.replace(/,(\\S)/g, ', $1'),\n              }\n            } else {\n              // remove rest of matchItems\n              record = null\n            }\n          }\n          return record\n        })\n      })\n    })\n\n    // split in keystrokes and barcodes\n    let handles = {}\n    records.forEach(record => {\n      if (record && record.box && typeof record.match === 'string') {\n        let toEndUser = {\n          match: record.match,\n          description: record.box.description,\n        }\n        handles.hotkeys = handles.hotkeys\n          ? handles.hotkeys.concat([toEndUser])\n          : [toEndUser]\n      }\n      if (record && record.box && record.match instanceof RegExp) {\n        let toEndUser = {\n          match: 'barcode', //record.match.toString(),\n          description: record.box.description,\n        }\n        handles.barcodes = handles.barcodes\n          ? handles.barcodes.concat([toEndUser])\n          : [toEndUser]\n      }\n    })\n    //console.log('overview:\\n' + JSON.stringify(handles))\n    return handles\n  }\n\n  /**\n   * Coerce a screen in the html - public toggle function\n   */\n  let toggleOverviewPanel = function() {\n    // initial direction; the other is removeOverviewHtml\n    appendOverviewHtml()\n  }\n\n  /**\n   * Coerce a screen in the html - append function\n   * @private\n   */\n  const appendOverviewHtml = function() {\n    const handles = overviewJson()\n\n    // build\n    let svgString = `\n    <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n    \t viewBox=\"0 0 507.2 507.2\" style=\"enable-background:new 0 0 507.2 507.2;\" xml:space=\"preserve\">\n    <circle fill=\"#000000\" cx=\"253.6\" cy=\"253.6\" r=\"253.6\"/>\n    <path fill=\"#FFFFFF\" d=\"M373.6,309.6c11.2,11.2,11.2,30.4,0,41.6l-22.4,22.4c-11.2,11.2-30.4,11.2-41.6,0l-176-176\n    \tc-11.2-11.2-11.2-30.4,0-41.6l23.2-23.2c11.2-11.2,30.4-11.2,41.6,0L373.6,309.6z\"/>\n    <path fill=\"#FFFFFF\" d=\"M309.6,133.6c11.2-11.2,30.4-11.2,41.6,0l23.2,23.2c11.2,11.2,11.2,30.4,0,41.6L197.6,373.6\n    \tc-11.2,11.2-30.4,11.2-41.6,0l-22.4-22.4c-11.2-11.2-11.2-30.4,0-41.6L309.6,133.6z\"/>\n    </svg>\n    `\n    let htmlString = `<table>`\n    const writeMatches = function(prop) {\n      let str = `<thead><tr><th colspan=\"2\">${prop}</th><tr></thead><tbody>`\n      for (let item of handles[prop] || []) {\n        str += `<tr><th>${item.match}</th><td>${item.description}</td></tr>`\n      }\n      return str + `</tbody>`\n    }\n    if (handles.hotkeys) {\n      htmlString += writeMatches('hotkeys')\n    }\n    if (handles.barcodes) {\n      htmlString += writeMatches('barcodes')\n    }\n    if (!handles.hotkeys && !handles.barcodes) {\n      htmlString += writeMatches('no hotkeys or barcodes configured')\n    }\n\n    htmlString += `</table>`\n    let panel = document.createElement('chars-and-chuncks-panel')\n    panel.innerHTML = svgString + htmlString\n\n    // apply\n    dataLockBox.overlay()\n    document.body.appendChild(panel)\n    panel\n      .querySelector('table:first-of-type')\n      .addEventListener('click', removeOverviewHtml)\n    panel\n      .querySelector('svg:first-of-type')\n      .addEventListener('click', removeOverviewHtml)\n\n    // direct the toggle\n    toggleOverviewPanel = function() {\n      removeOverviewHtml()\n    }\n  }\n\n  /**\n   * Remove the open help-screen in the html\n   * @private\n   */\n  const removeOverviewHtml = function() {\n    const panel = document.querySelector('chars-and-chuncks-panel')\n    panel\n      .querySelector('table:first-of-type')\n      .removeEventListener('click', removeOverviewHtml)\n    panel\n      .querySelector('svg:first-of-type')\n      .removeEventListener('click', removeOverviewHtml)\n    panel.remove()\n    dataLockBox.revive()\n\n    // direct the toggle\n    toggleOverviewPanel = function() {\n      appendOverviewHtml()\n    }\n  }\n\n  return {\n    register: register,\n    hotkeyHandler: hotkeyHandler,\n    barcodeHandler: barcodeHandler,\n    overviewJson: overviewJson,\n    overviewPanel: toggleOverviewPanel,\n    reset: dataLockBox.reset,\n    mute: dataLockBox.mute,\n    free: dataLockBox.free,\n    overlay: dataLockBox.overlay,\n    revive: dataLockBox.revive,\n  }\n})()\n\nexport { collectionManagement }\n","let config = {\n  // Maximum time the barcode scanner takes to send the next character\n  safeIntermission: 30,\n  // General treshold to prevent accidental elbow-on-keyboard processing\n  minimalBarcodeLength: 6,\n}\n\nexport { config }\n","import { collectionManagement } from './collectionManagement'\nimport { config } from './configuration'\n\nconst charsAndChunksModule = (function() {\n  // modifiers allowed to compose a character\n  const allowedModifiers = ['Shift', 'Alt']\n\n  // Process variables\n  let streamTimeout = 0\n  let stream = []\n\n  // we leave entry with on-the-fly editing to form controls\n  const fromFormControl = event => {\n    return (\n      event.target.tagName === 'INPUT' ||\n      event.target.tagName === 'TEXTAREA' ||\n      event.target.tagName === 'SELECT'\n    )\n  }\n\n  const settleStream = function(event) {\n    // We only deal with single characters or barcodes.\n    let settle = stream.join('')\n    if (stream.length >= config.minimalBarcodeLength) {\n      let handle = collectionManagement.barcodeHandler(settle)\n      // console.log('handle barcode', settle, handle)\n      if (handle) {\n        handle.callback(settle)\n      }\n    } else if (stream.length === 1) {\n      if (event.ctrlKey) settle = `ctrl+${settle}`\n      let handle = collectionManagement.hotkeyHandler(settle)\n      // console.log('handle hotkey', settle, handle)\n      if (handle) {\n        handle.callback(settle)\n      }\n    } else {\n      //console.log(`invalid stream length: ${stream.length} (${settle})`)\n    }\n    stream = []\n  }\n\n  const streamHandler = function(event) {\n    //console.log(`input: ${event.key}`)\n    if (streamTimeout) {\n      clearTimeout(streamTimeout)\n    }\n\n    // We expect our input can safely be processed; we ignore typing in form controls\n    if (fromFormControl(event)) {\n      stream = []\n      return\n    }\n\n    // We expect our barcode scanner to send character by character.\n    const multiChar = event.key.length > 1\n    if (multiChar) {\n      // Do not wait for new characters\n      // console.log(`out of scope: '${event.key}' in stream: '${stream}'`)\n      if (stream.length && event.key === 'Enter') {\n        settleStream(event)\n        return\n      } else if (!allowedModifiers.includes(event.key)) {\n        // pageDown, Tab, Backspace, etc.\n        // Do not use previous characters also\n        stream = [event.key]\n        settleStream(event)\n        return\n      }\n      // With allowedModifiers we want to set a new timeout\n    } else {\n      // barcode characters pass here\n      stream.push(event.key)\n    }\n\n    streamTimeout = setTimeout(settleStream, config.safeIntermission, event)\n  }\n\n  window.addEventListener('keydown', streamHandler)\n\n  const configure = function(change) {\n    Object.getOwnPropertyNames(change).forEach(prop => {\n      const oldValue = config[prop]\n      const newValue = change[prop]\n      if (typeof oldValue === typeof newValue) {\n        config[prop] = newValue\n      }\n    })\n  }\n\n  return {\n    publicAPI: {\n      config: configure,\n      register: collectionManagement.register,\n      overview: collectionManagement.overviewJson,\n      help: collectionManagement.overviewPanel,\n      reset: collectionManagement.reset,\n      mute: collectionManagement.mute,\n      free: collectionManagement.free,\n      overlay: collectionManagement.overlay,\n      revive: collectionManagement.revive,\n    },\n    testAPI: {\n      hotkeyHandler: collectionManagement.hotkeyHandler,\n      barcodeHandler: collectionManagement.barcodeHandler,\n    },\n  }\n})()\n\nconst charsAndChunks = charsAndChunksModule.publicAPI\nconst charsAndTests = charsAndChunksModule.testAPI\n\nexport { charsAndChunks, charsAndTests }\n","import { charsAndChunks } from './charsAndChunks'\nimport './helpScreen.scss'\n\nconst index = charsAndChunks\n\nexport default index\n"],"names":["dataLockBox","LockBoxModel","this","lock","Map","box","WeakMap","data","stash","retrieve","props","has","entry","context","get","mute","undefined","reset","toggle","entries","length","Array","from","flat","keys","store","OK","console","error","storageSanity","set","match","overview","records","key","record","push","call","arguments","free","overlay","Object","assign","revive","pop","cleanup","forEach","matchyVal","delete","collectionManagement","register","time","Date","now","random","Math","floor","matchProps","matchItem","matchOK","toString","RegExp","contextOK","document","querySelector","callbackOK","callback","descriptionOK","description","registrationSanity","internals","registerMatch","overviewJson","matchRecords","peers","filter","other","matches","map","peer","multiMatch","split","matchIndex","replace","handles","toEndUser","hotkeys","concat","barcodes","toggleOverviewPanel","appendOverviewHtml","htmlString","writeMatches","prop","str","item","panel","createElement","innerHTML","body","appendChild","addEventListener","removeOverviewHtml","removeEventListener","remove","hotkeyHandler","char","handle","some","includes","Boolean","barcodeHandler","barcode","pattern","regex","test","barcodeMatch","overviewPanel","config","safeIntermission","minimalBarcodeLength","index","allowedModifiers","streamTimeout","stream","settleStream","event","settle","join","ctrlKey","window","clearTimeout","target","tagName","fromFormControl","setTimeout","publicAPI","change","getOwnPropertyNames","oldValue","newValue","help","testAPI"],"mappings":"AAAA,MAAMA,EAAc,WAMlB,MAAMC,EAAe,WACnBC,KAAKC,KAAO,IAAIC,IAChBF,KAAKG,IAAM,IAAIC,SAGjB,IAAIC,EAAO,IAAIN,EAEXO,EAAQ,GAOZ,MA0CMC,EAAW,SAASC,GAGxB,GAAIH,EAAKJ,KAAKQ,IAAID,EAAME,OAAQ,CAE9B,IAAIC,EAAUN,EAAKJ,KAAKW,IAAIJ,EAAME,OAElC,GAAIC,GAAWN,EAAKF,IAAIM,IAAIE,GAAU,CACpC,MAAMR,EAAME,EAAKF,IAAIS,IAAID,GAASH,EAAME,OAExC,OAAOP,IAAQA,EAAIU,KAAOV,OAAMW,KA2BhCC,EAAQ,WACZV,EAAO,IAAIN,GAQPc,EAAO,SAASG,GACpB,MAAMC,EAAUjB,KAAKkB,OAASC,MAAMC,KAAKpB,MAAMqB,OAAShB,EAAKJ,KAAKqB,OAClE,IAAK,MAAMZ,KAASO,EAClB,GAAIZ,EAAKJ,KAAKQ,IAAIC,GAAQ,CACxB,MAAMC,EAAUN,EAAKJ,KAAKW,IAAIF,GAC9B,GAAIC,GAAWN,EAAKF,IAAIM,IAAIE,GAAU,CACxBN,EAAKF,IAAIS,IAAID,GAASD,GAC9BG,KAAOG,KAyCnB,MAAO,CACLO,MApHY,SAASf,EAAOL,IArBR,SAASK,GAC7B,MAAMgB,EAA8B,iBAAlBhB,EAAMG,QAIxB,OAHKa,GACHC,QAAQC,MAAM,gBAETF,GAkBFG,CAAcnB,KAEnBH,EAAKJ,KAAK2B,IAAIpB,EAAMqB,MAAOrB,EAAMG,SAE5BN,EAAKF,IAAIM,IAAID,EAAMG,UACtBN,EAAKF,IAAIyB,IAAIpB,EAAMG,QAAS,IAI9BN,EAAKF,IAAIS,IAAIJ,EAAMG,SAASH,EAAMqB,OAAS1B,IA0G3CI,SAAUA,EACVe,KAAM,WACJ,OAAOjB,EAAKJ,KAAKqB,QAEnBQ,SAjFe,WACf,IAAIC,EAAU,GACd,MAAMT,EAAOjB,EAAKJ,KAAKqB,OAEvB,IAAK,IAAIU,KAAOV,EAAM,CACpB,IAAInB,EAAMI,EAAS,CAAEG,MAAOsB,IAC5B,GAAI3B,EAAKJ,KAAKW,IAAIoB,GAAM,CACtB,IAAIC,EAAS,CAAEJ,MAAOG,EAAK7B,IAAKA,GAChC4B,EAAQG,KAAKD,IAIjB,OAAOF,GAsEPhB,MAAOA,EACPF,KAAM,WACJA,EAAKsB,KAAKC,WAAW,IAEvBC,KAAM,WACJxB,EAAKsB,KAAKC,WAAW,IAEvBE,QA9Cc,WACdhC,EAAM4B,KAAKK,OAAOC,OAAO,GAAInC,IAC7BU,KA6CA0B,OAtCa,WACTnC,EAAMY,SAERb,EAAOC,EAAMoC,QAoCfC,QA5Bc,SAAShC,GAEvBN,EAAKJ,KAAK2C,SAAQ,CAACC,EAAWhB,KAExBxB,EAAKJ,KAAKW,IAAIiB,KAAWlB,GAE3BN,EAAKJ,KAAK6C,OAAOjB,MAGrBxB,EAAKF,IAAI2C,OAAOnC,KAzJA,GCEdoC,EAAuB,WAO3B,MAiDMC,EAAW,SACfxC,EACAG,EAAU,CACRsC,KAAMC,KAAKC,MACXC,OAAQC,KAAKC,MAAMD,KAAKD,SAAWC,KAAKC,MAAM,UAG5C9C,aAAiBW,MAEnBX,EAAMoC,SAAQW,IACZP,EAASO,EAAY5C,OAGvBH,EAAMG,QAAUA,EAGZH,EAAMqB,iBAAiBV,MAEzBX,EAAMqB,MAAMe,SAAQY,IAClB,MAAMD,EAAa,IACd/C,EACHqB,MAAO2B,GAETR,EAASO,EAAY5C,MAxEF,SAASH,GAClC,MAAMiD,EACJjD,EAAMqB,OACNrB,EAAMqB,MAAM6B,WAAWxC,SACC,iBAAhBV,EAAMqB,OAAsBrB,EAAMqB,iBAAiB8B,QACvDC,GACyB,iBAAlBpD,EAAMG,UACfH,EAAMG,QAAUkD,SAASC,cAActD,EAAMG,UAExCH,EAAMG,SAAoC,iBAAlBH,EAAMG,SAGjCoD,EAAuC,mBAAnBvD,EAAMwD,SAC1BC,EACyB,iBAAtBzD,EAAM0D,aAA4B1D,EAAM0D,YAAYhD,OAU7D,OATWuC,GAAWG,GAAaG,GAAcE,EA6DzCE,CAAmB3D,IAxCP,SAASA,GAC7B,MAAM4D,EAAY,CAChBJ,SAAUxD,EAAMwD,SAChBE,YAAa1D,EAAM0D,aAErBpE,EAAYyB,MAAMf,EAAO4D,GAoCnBC,CAAc7D,IASpB,OAHkB,WAChBV,EAAY6C,QAAQhC,KAwElB2D,EAAe,WACnB,IAAIvC,EAAUjC,EAAYgC,WAGtByC,EAAe,IAAIhC,OACvBR,EAAQa,SAAQX,IACd,IAAIuC,EAAQzC,EAAQ0C,QAClBC,GACEA,EAAMvE,KACN8B,EAAO9B,KACPuE,EAAMvE,IAAI6D,WAAa/B,EAAO9B,IAAI6D,UAClCU,EAAMvE,IAAI+D,cAAgBjC,EAAO9B,IAAI+D,cAEzC,GAAIM,EAAMtD,OAAS,EAAG,CACpB,IAAIyD,EAAUH,EAAMI,KAAIC,GAAQA,EAAKhD,QACrC0C,EAAaI,GAAW,UAKPpC,OAAOjB,KAAKiD,GACpB3B,SAAQkC,IACKA,EAAWC,MAAM,KACzBnC,SAAQ,CAACY,EAAWwB,KAClCjD,EAAUA,EAAQ6C,KAAI3C,IAChBA,GAAUA,EAAOJ,QAAU2B,IAS3BvB,EARG+C,EAQM,KANA,IACJ/C,EACHJ,MAAOiD,EAAWG,QAAQ,SAAU,UAOnChD,WAMb,IAAIiD,EAAU,GAsBd,OArBAnD,EAAQa,SAAQX,IACd,GAAIA,GAAUA,EAAO9B,KAA+B,iBAAjB8B,EAAOJ,MAAoB,CAC5D,IAAIsD,EAAY,CACdtD,MAAOI,EAAOJ,MACdqC,YAAajC,EAAO9B,IAAI+D,aAE1BgB,EAAQE,QAAUF,EAAQE,QACtBF,EAAQE,QAAQC,OAAO,CAACF,IACxB,CAACA,GAEP,GAAIlD,GAAUA,EAAO9B,KAAO8B,EAAOJ,iBAAiB8B,OAAQ,CAC1D,IAAIwB,EAAY,CACdtD,MAAO,UACPqC,YAAajC,EAAO9B,IAAI+D,aAE1BgB,EAAQI,SAAWJ,EAAQI,SACvBJ,EAAQI,SAASD,OAAO,CAACF,IACzB,CAACA,OAIFD,GAMT,IAAIK,EAAsB,WAExBC,KAOF,MAAMA,EAAqB,WACzB,MAAMN,EAAUZ,IAGhB,IAUImB,EAAa,UACjB,MAAMC,EAAe,SAASC,GAC5B,IAAIC,EAAM,8BAA8BD,4BACxC,IAAK,IAAIE,KAAQX,EAAQS,IAAS,GAChCC,GAAO,WAAWC,EAAKhE,iBAAiBgE,EAAK3B,wBAE/C,OAAO0B,EAAM,YAEXV,EAAQE,UACVK,GAAcC,EAAa,YAEzBR,EAAQI,WACVG,GAAcC,EAAa,aAExBR,EAAQE,SAAYF,EAAQI,WAC/BG,GAAcC,EAAa,sCAG7BD,GAAc,WACd,IAAIK,EAAQjC,SAASkC,cAAc,2BACnCD,EAAME,UA9BU,4tBA8BcP,EAG9B3F,EAAYwC,UACZuB,SAASoC,KAAKC,YAAYJ,GAC1BA,EACGhC,cAAc,uBACdqC,iBAAiB,QAASC,GAC7BN,EACGhC,cAAc,qBACdqC,iBAAiB,QAASC,GAG7Bb,EAAsB,WACpBa,MAQEA,EAAqB,WACzB,MAAMN,EAAQjC,SAASC,cAAc,2BACrCgC,EACGhC,cAAc,uBACduC,oBAAoB,QAASD,GAChCN,EACGhC,cAAc,qBACduC,oBAAoB,QAASD,GAChCN,EAAMQ,SACNxG,EAAY2C,SAGZ8C,EAAsB,WACpBC,MAIJ,MAAO,CACLxC,SAAUA,EACVuD,cAzNoB,SAASC,GAE7B,GAAa,MAATA,EAEG,CACL,IAAIC,EAAS3G,EAAYS,SAAS,CAAEG,MAAO8F,IAC3C,IAAKC,EAAQ,CACK3G,EAAYgC,WACpB4E,MAAKzE,IACPA,EAAOJ,iBAAiBV,OAASc,EAAOJ,MAAM8E,SAASH,KACzDC,EAAS3G,EAAYS,SAAS,CAAEG,MAAOuB,EAAOJ,SAGzC+E,QAAQH,MAGnB,OAAOA,EAbPlB,KAuNFsB,eAzKqB,SAASC,GAE9B,MAAMC,EAzBa,SAASD,GAC5B,IAAIE,EAAQ,GACZ,MAAM1F,EAAOxB,EAAYwB,OAEzB,IAAK,IAAIU,KAAOV,EAEVU,aAAe2B,QAAU3B,EAAIiF,KAAKH,IAEhC9E,EAAI0B,WAAWxC,OAAS8F,EAAMtD,WAAWxC,SAC3C8F,EAAQhF,GAMd,OAAOgF,EAUSE,CAAaJ,GAI7B,OAFkBhH,EAAYS,SAAS,CAAEG,MAAOqG,KAsKhDzC,aAAcA,EACd6C,cAAe5B,EACfxE,MAAOjB,EAAYiB,MACnBF,KAAMf,EAAYe,KAClBwB,KAAMvC,EAAYuC,KAClBC,QAASxC,EAAYwC,QACrBG,OAAQ3C,EAAY2C,QAtUK,GCF7B,IAAI2E,EAAS,CAEXC,iBAAkB,GAElBC,qBAAsB,GCDxB,MCAMC,EDAuB,WAE3B,MAAMC,EAAmB,CAAC,QAAS,OAGnC,IAAIC,EAAgB,EAChBC,EAAS,GAGb,MAQMC,EAAe,SAASC,GAE5B,IAAIC,EAASH,EAAOI,KAAK,IACzB,GAAIJ,EAAOxG,QAAUkG,EAAOE,qBAAsB,CAChD,IAAIb,EAAS1D,EAAqB8D,eAAegB,GAE7CpB,GACFA,EAAOzC,SAAS6D,QAEb,GAAsB,IAAlBH,EAAOxG,OAAc,CAC1B0G,EAAMG,UAASF,EAAS,QAAQA,KACpC,IAAIpB,EAAS1D,EAAqBwD,cAAcsB,GAE5CpB,GACFA,EAAOzC,SAAS6D,GAKpBH,EAAS,IAuCXM,OAAO7B,iBAAiB,WApCF,SAASyB,GAO7B,GALIH,GACFQ,aAAaR,GAjCOG,CAAAA,GAEK,UAAzBA,EAAMM,OAAOC,SACY,aAAzBP,EAAMM,OAAOC,SACY,WAAzBP,EAAMM,OAAOC,QAiCXC,CAAgBR,GAElB,YADAF,EAAS,IAMX,GADkBE,EAAM5F,IAAId,OAAS,EACtB,CAGb,GAAIwG,EAAOxG,QAAwB,UAAd0G,EAAM5F,IAEzB,YADA2F,EAAaC,GAER,IAAKJ,EAAiBb,SAASiB,EAAM5F,KAK1C,OAFA0F,EAAS,CAACE,EAAM5F,UAChB2F,EAAaC,QAMfF,EAAOxF,KAAK0F,EAAM5F,KAGpByF,EAAgBY,WAAWV,EAAcP,EAAOC,iBAAkBO,MAepE,MAAO,CACLU,UAAW,CACTlB,OAZc,SAASmB,GACzBhG,OAAOiG,oBAAoBD,GAAQ3F,SAAQ+C,IACzC,MAAM8C,EAAWrB,EAAOzB,GAClB+C,EAAWH,EAAO5C,UACb8C,UAAoBC,IAC7BtB,EAAOzB,GAAQ+C,OAQjB1F,SAAUD,EAAqBC,SAC/BlB,SAAUiB,EAAqBuB,aAC/BqE,KAAM5F,EAAqBoE,cAC3BpG,MAAOgC,EAAqBhC,MAC5BF,KAAMkC,EAAqBlC,KAC3BwB,KAAMU,EAAqBV,KAC3BC,QAASS,EAAqBT,QAC9BG,OAAQM,EAAqBN,QAE/BmG,QAAS,CACPrC,cAAexD,EAAqBwD,cACpCM,eAAgB9D,EAAqB8D,iBArGd,GA0GeyB"}