{"version":3,"file":"charsAndChunks.js","sources":["../src/dataLockBox.js","../src/collectionManagement.js","../src/charsAndChunks.js"],"sourcesContent":["const dataLockBox = (function() {\n  /**\n   * Definition of storage structure\n   * @member {Map} lock - Map of characters and regular expressions holding a context.\n   * @member {WeakMap} box - WeakMap of contexts holding an object with a single charcter, a callback and optionally a comment\n   */\n  const LockBoxModel = function() {\n    this.lock = new Map()\n    this.box = new WeakMap()\n  }\n\n  let data = new LockBoxModel()\n\n  /**\n   * Snaity check for storage\n   * @private\n   * @returns {boolean} is sane\n   */\n  const storageSanity = function(props) {\n    const OK = typeof props.context === 'object'\n    if (!OK) {\n      console.error('Cannot store')\n    }\n    return OK\n  }\n\n  /**\n   * Store a user entry and a validatable context as lock\n   * and a context as a box with entries holding data\n   * @private\n   * @param {object} props\n   *    @member {primitive | object} entry\n   *    @member {object} context\n   *    @member {primitive | object} box - the data itself\n   */\n  const store = function(props) {\n    if (!storageSanity(props)) return\n    // Register context with string or regular expression in a Map\n    data.lock.set(props.entry, props.context)\n    if (!data.box.has(props.context)) {\n      data.box.set(props.context, {})\n    }\n    // Register data with context in a WeakMap\n    data.box.get(props.context)[props.entry] = props.box\n  }\n\n  /**\n   * Generic positive validator\n   * @private\n   * @returns {boolean} truth\n   */\n  const returnTrue = function() {\n    return true\n  }\n\n  /**\n   * Find the right data for entry\n   * @param {object} props\n   *   @member {string} entry - key for the lock map\n   * @returns {object} stored data object\n   */\n  const retrieve = function(props, contextValidator = returnTrue) {\n    //console.log(`entry to handle: ${props.entry}`)\n\n    if (data.lock.has(props.entry)) {\n      // find context from lock,\n      let context = data.lock.get(props.entry)\n      if (context && data.box.has(context)) {\n        if (contextValidator(context)) {\n          return data.box.get(context)[props.entry]\n        } else {\n          data.lock.set(props.entry, undefined)\n          data.box.delete(context)\n        }\n      }\n    }\n  }\n\n  /**\n   * Generate a list of active entries (those with a valid context)\n   * @returns {Array} records\n   */\n  const overview = function(contextValidator = returnTrue) {\n    let records = []\n    const keys = data.lock.keys()\n\n    for (let key of keys) {\n      let box = retrieve({ entry: key }, contextValidator)\n      if (data.lock.get(key)) {\n        let record = { entry: key, box: box }\n        records.push(record)\n      }\n    }\n    //console.log('overview' + JSON.stringify(records))\n    return records\n  }\n\n  /**\n   * Clear all entries and data\n   */\n  const reset = function() {\n    data = new LockBoxModel()\n  }\n\n  return {\n    store: store,\n    retrieve: retrieve,\n    keys: function() {\n      return data.lock.keys()\n    },\n    overview: overview,\n    reset: reset,\n  }\n})()\n\nexport { dataLockBox }\n","import { dataLockBox } from './dataLockBox'\n\nconst collectionManagement = (function() {\n  /**\n   * Default regular expression.\n   */\n  const catchAllRegExp = /^/\n\n  /**\n   * Check sanity of a registration object\n   * @private\n   * @param {object} props\n   */\n  const registrationSanity = function(props) {\n    const matchOK = (function() {\n      if (props.char) {\n        return typeof props.char === 'string'\n      } else if (props.regex) {\n        return props.regex instanceof RegExp\n      }\n    })()\n    const contextOK = (function() {\n      if (typeof props.context === 'string') {\n        props.context = document.querySelector(props.context)\n      }\n      return props.context instanceof Node\n    })()\n    const callbackOK = typeof props.callback === 'function'\n    // check optional comment\n    if (!props.comment || typeof props.comment !== 'string') {\n      props.comment = `callback for ${props.char || 'barcode'}`\n    }\n    const OK = matchOK && contextOK && callbackOK\n    if (!OK) {\n      console.error('Wrong properties for registering hotkeys or barcodes!')\n      //console.log(props)\n    }\n    return OK\n  }\n\n  /**\n   * Register a context to trigger a function when any barcode is encountered\n   * @private\n   * @param {object} props\n   *    @member {string} char (conditionally optional)\n   *    @member {RegExp} regex (conditionally optional)\n   *    @member {object} context - Node\n   *    @member {function} callback\n   *    @member {string} comment (optional)\n   */\n  const registerEntry = function(props) {\n    props.entry = props.char || props.regex\n    props.box = {\n      callback: props.callback,\n      comment: props.comment,\n    }\n    dataLockBox.store(props)\n  }\n\n  /**\n   * Register a context to trigger a function when the character is pressed\n   * @param {object} props\n   */\n  const registerHotkey = function(props) {\n    delete props.regex\n    if (registrationSanity(props)) {\n      registerEntry(props)\n      //console.log(`hotkey registered: ${props.char}`)\n    }\n  }\n\n  /**\n   * Check for the node being inside the DOM\n   * @private\n   * @param {Node} node\n   * @returns {boolean} boolean - true when the node is onscreen -- not removed\n   */\n  const isAttached = function(elm) {\n    return (\n      elm &&\n      (elm.getRootNode() instanceof Document ||\n        elm.getRootNode() instanceof ShadowRoot)\n    )\n  }\n\n  /**\n   * Find the right data for hotkey\n   * @param {string} char\n   * @returns {object} data object\n   */\n  const hotkeyHandler = function(char) {\n    return dataLockBox.retrieve({ entry: char }, isAttached)\n  }\n\n  /**\n   * Register a context to trigger a function when any barcode is encountered\n   * @param {object} props\n   */\n  const registerBarcode = function(props) {\n    delete props.char\n    if (!props.regex) {\n      props.regex = catchAllRegExp\n    }\n    if (registrationSanity(props)) {\n      registerEntry(props)\n      //console.log(`barcode registered: ${props.regex}`)\n    }\n  }\n\n  /**\n   * Find the lengthiest RegExp for barcode\n   * @private\n   * @param {string} barcode\n   * @returns {RegExp}\n   */\n  const barcodeMatch = function(barcode) {\n    let regex = catchAllRegExp\n    const keys = dataLockBox.keys()\n\n    for (let key of keys) {\n      if (key instanceof RegExp && key.test(barcode)) {\n        // find the most complex RegExp\n        if (key.toString().length > regex.toString().length) {\n          regex = key\n        }\n      }\n    }\n    return regex\n  }\n\n  /**\n   * Find the right data for barcode\n   * @param {string} barcode\n   * @returns {object} data object\n   */\n  const barcodeHandler = function(barcode) {\n    const regex = barcodeMatch(barcode)\n    return dataLockBox.retrieve({ entry: regex }, isAttached)\n  }\n\n  /**\n   * Generate a list of active entries (those with a valid context)\n   * @returns {object}\n   */\n  const overview = function() {\n    let handles = []\n    const records = dataLockBox.overview(isAttached)\n\n    records.forEach(record => {\n      if (record.box && typeof record.entry === 'string') {\n        let toEndUser = {\n          entry: record.entry,\n          comment: record.box.comment,\n        }\n        handles.hotkey = handles.hotkey\n          ? handles.hotkey.concat([toEndUser])\n          : [toEndUser]\n      }\n      if (record.box && record.entry instanceof RegExp) {\n        let toEndUser = {\n          entry: 'barcode', //record.entry.toString(),\n          comment: record.box.comment,\n        }\n        handles.barcode = handles.barcode\n          ? handles.barcode.concat([toEndUser])\n          : [toEndUser]\n      }\n    })\n    //console.log('overview' + JSON.stringify(handles))\n    return handles\n  }\n\n  return {\n    registerHotkey: registerHotkey,\n    hotkeyHandler: hotkeyHandler,\n    registerBarcode: registerBarcode,\n    barcodeHandler: barcodeHandler,\n    overview: overview,\n    reset: dataLockBox.reset,\n  }\n})()\n\nexport { collectionManagement }\n","import { collectionManagement } from './collectionManagement'\n\nconst charsAndChunksModule = (function() {\n  // Maximum time the barcode scanner takes to send the next character\n  let safeIntermission = 30\n  // General treshold to prevent accidental elbow-on-keyboard processing\n  let minimalBarcodeLength = 6\n\n  const allowedModifiers = ['Shift']\n  // Process variables\n  let streamTimeout = 0\n  let stream = []\n\n  const settleStream = function(event) {\n    // We only deal with single characters or barcodes.\n    let settle = stream.join('')\n    if (stream.length >= minimalBarcodeLength) {\n      //console.log(`handle as barcode: ${settle} (${stream.length})`)\n      let handle = collectionManagement.barcodeHandler(settle)\n      if (handle) {\n        handle.callback(settle)\n      }\n    } else if (stream.length === 1) {\n      //console.log(`handle as character: ${settle} (${stream.length})`)\n      if (event.ctrlKey) settle = `ctrl+${settle}`\n      let handle = collectionManagement.hotkeyHandler(settle)\n      if (handle) {\n        handle.callback(settle)\n      }\n    } else {\n      //console.log(`invalid stream length: ${stream.length} (${settle})`)\n    }\n    stream = []\n  }\n\n  const streamHandler = function(event) {\n    //console.log(`input: ${event.key}`)\n    if (streamTimeout) {\n      clearTimeout(streamTimeout)\n    }\n\n    // We expect our input can safely be processed; we leave entry with on-the-fly editing to form controls\n    const fromFormControl =\n      event.target.tagName === 'INPUT' ||\n      event.target.tagName === 'TEXTAREA' ||\n      event.target.tagName === 'SELECT'\n    if (fromFormControl) {\n      stream = []\n      return\n    }\n\n    // We expect our barcode scanner to send character by character.\n    const multiChar = event.key.length > 1\n    if (multiChar) {\n      // Do not wait for new characters\n      //console.log(`out of scope: '${event.key}' in stream: '${stream}'`)\n      if (event.key === 'Enter') {\n        settleStream(event)\n        return\n      } else if (!allowedModifiers.includes(event.key)) {\n        // pageDown, Tab, Backspace, etc.\n        // Do not use previous characters also\n        stream = [event.key]\n        settleStream(event)\n        return\n      }\n      // With allowedModifiers we want to set a new timeout\n    } else {\n      stream.push(event.key)\n    }\n\n    streamTimeout = setTimeout(settleStream, safeIntermission, event)\n  }\n\n  window.addEventListener('keydown', streamHandler)\n\n  return {\n    publicAPI: {\n      hotkey: collectionManagement.registerHotkey,\n      barcode: collectionManagement.registerBarcode,\n      overview: collectionManagement.overview,\n      reset: collectionManagement.reset,\n    },\n    testAPI: {\n      hotkeyHandler: collectionManagement.hotkeyHandler,\n      barcodeHandler: collectionManagement.barcodeHandler,\n    },\n  }\n})()\n\nconst charsAndChunks = charsAndChunksModule.publicAPI\nconst charsAndTests = charsAndChunksModule.testAPI\n\nexport { charsAndChunks, charsAndTests }\n"],"names":["dataLockBox","LockBoxModel","this","lock","Map","box","WeakMap","data","returnTrue","retrieve","props","contextValidator","has","entry","context","get","set","undefined","delete","store","OK","console","error","storageSanity","keys","overview","records","key","record","push","reset","collectionManagement","catchAllRegExp","registrationSanity","matchOK","char","regex","RegExp","contextOK","document","querySelector","Node","callbackOK","callback","comment","registerEntry","isAttached","elm","getRootNode","Document","ShadowRoot","registerHotkey","hotkeyHandler","registerBarcode","barcodeHandler","barcode","test","toString","length","barcodeMatch","handles","forEach","toEndUser","hotkey","concat","allowedModifiers","streamTimeout","stream","settleStream","event","settle","join","handle","ctrlKey","window","addEventListener","clearTimeout","target","tagName","includes","setTimeout","publicAPI","testAPI"],"mappings":"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"}