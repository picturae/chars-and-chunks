{"version":3,"file":"charsAndChunks.js","sources":["../src/dataLockBox.js","../src/collectionManagement.js","../src/charsAndChunks.js"],"sourcesContent":["const dataLockBox = (function() {\n  /**\n   * Definition of storage structure\n   * @member {Map} lock - Map of characters and regular expressions holding a context.\n   * @member {WeakMap} box - WeakMap of contexts holding an object with a single charcter, a callback and a description\n   */\n  const LockBoxModel = function() {\n    this.lock = new Map()\n    this.box = new WeakMap()\n  }\n\n  let data = new LockBoxModel()\n\n  let stash = []\n\n  /**\n   * Snaity check for storage\n   * @private\n   * @returns {boolean} is sane\n   */\n  const storageSanity = function(props) {\n    const OK = typeof props.context === 'object'\n    if (!OK) {\n      console.error('Cannot store')\n    }\n    return OK\n  }\n\n  /**\n   * Store a user match and a context as lock\n   * and a context as a box with matches holding data\n   * @private\n   * @param {object} props\n   *    @member {primitive | object} match\n   *    @member {object} context\n   *    @member {primitive | object} box - the data itself\n   */\n  const store = function(props) {\n    if (!storageSanity(props)) return\n    // Register context with string or regular expression in a Map\n    data.lock.set(props.match, props.context)\n    if (!data.box.has(props.context)) {\n      data.box.set(props.context, {})\n    }\n    // Register data with context in a WeakMap\n    data.box.get(props.context)[props.match] = props.box\n  }\n\n  /**\n   * Find the right data for entry\n   * @param {object} props\n   *   @member {string} match - key for the lock map\n   * @returns {object} stored data object\n   */\n  const retrieve = function(props) {\n    //console.log(`match to handle: ${props.match}`)\n\n    if (data.lock.has(props.entry)) {\n      // find context from lock,\n      let context = data.lock.get(props.entry)\n      if (context && data.box.has(context)) {\n        return data.box.get(context)[props.entry]\n      }\n    }\n  }\n\n  /**\n   * Generate a list of active matches (those with a not-cleaned-up context)\n   * @returns {Array} records\n   */\n  const overview = function() {\n    let records = []\n    const keys = data.lock.keys()\n\n    for (let key of keys) {\n      let box = retrieve({ entry: key })\n      if (data.lock.get(key)) {\n        let record = { match: key, box: box }\n        records.push(record)\n      }\n    }\n    //console.log('overview' + JSON.stringify(records))\n    return records\n  }\n\n  /**\n   * Clear all matches and data\n   */\n  const reset = function() {\n    data = new LockBoxModel()\n  }\n\n  /*\n   * Disable all current data en put up a clean storage\n   */\n  const overlay = function() {\n    stash.push(Object.assign({}, data))\n    reset()\n    //console.log(`go to stack level ${stash.length}`)\n  }\n\n  /*\n   * Remove the superseded data and enable the previous data\n   */\n  const revive = function() {\n    if (stash.length) {\n      //console.log(`remove stack level ${stash.length}`)\n      data = stash.pop()\n    }\n  }\n\n  /*\n   * Remove references to contexts\n   * @param {object} context\n   */\n  const cleanup = function(context) {\n    // console.log(`cleanup context '${context.toString()}'`)\n    data.lock.forEach((matchyVal, match) => {\n      if (data.lock.get(match) === context) {\n        // console.log(`cleanup '${data.box.get(context)[match].description}'`)\n        data.lock.set(match, undefined)\n      }\n    })\n    data.box.delete(context)\n  }\n\n  return {\n    store: store,\n    retrieve: retrieve,\n    keys: function() {\n      return data.lock.keys()\n    },\n    overview: overview,\n    reset: reset,\n    overlay: overlay,\n    revive: revive,\n    cleanup: cleanup,\n  }\n})()\n\nexport { dataLockBox }\n","import { dataLockBox } from './dataLockBox'\n\nconst collectionManagement = (function() {\n  /**\n   * Default regular expression.\n   */\n  const catchAllRegExp = /^/\n\n  /**\n   * Check sanity of a registration object\n   * @private\n   * @param {object} props\n   */\n  const registrationSanity = function(props) {\n    const matchOK = (function() {\n      if (props.char) {\n        return typeof props.char === 'string' && props.char.length\n      } else if (props.regex) {\n        return props.regex instanceof RegExp\n      }\n    })()\n    const contextOK = (function() {\n      if (typeof props.context === 'string') {\n        props.context = document.querySelector(props.context)\n      }\n      return typeof props.context === 'object' //props.context instanceof Node\n    })()\n    const callbackOK = typeof props.callback === 'function'\n    const descriptionOK =\n      typeof props.description === 'string' && props.description.length\n    const OK = matchOK && contextOK && callbackOK && descriptionOK\n    if (!OK) {\n      console.error('Wrong properties for registering hotkeys or barcodes!')\n      if (location.port) console.log(props)\n    }\n    return OK\n  }\n\n  /**\n   * Register a context to trigger a function when any barcode is encountered\n   * @private\n   * @param {object} props\n   *    @member {string} char (conditionally optional)\n   *    @member {RegExp} regex (conditionally optional)\n   *    @member {object} context - Node\n   *    @member {function} callback\n   *    @member {string} description\n   */\n  const registerMatch = function(props) {\n    props.match = props.char || props.regex\n    props.box = {\n      callback: props.callback,\n      description: props.description,\n    }\n    dataLockBox.store(props)\n  }\n\n  /**\n   * Register a context to trigger a function when the character is pressed\n   * @param {object} props\n   */\n  const registerHotkey = function(props) {\n    delete props.regex\n    if (props.char instanceof Array) {\n      // route items in mulltiple match registrations\n      let lastSanePropIfAny, lastProp\n      props.char.forEach(char => {\n        const singleCharProps = Object.assign({}, props, { char: char })\n        lastProp = registerHotkey(singleCharProps)\n        if (lastProp) lastSanePropIfAny = lastProp\n      })\n      return lastSanePropIfAny\n    } else {\n      // simple flow\n      if (registrationSanity(props)) {\n        registerMatch(props)\n        // console.log(`hotkey registered: ${props.char}`)\n        return props\n      }\n    }\n  }\n\n  const registerHotkeys = function(propsList) {\n    let refsList = []\n    propsList.forEach(props => {\n      let refs = registerHotkey(props)\n      if (refs) refsList.push(refs)\n    })\n    return refsList\n  }\n\n  /**\n   * Find the right data for hotkey\n   * @param {string} char\n   * @returns {object} data object\n   */\n  const hotkeyHandler = function(char) {\n    //console.log('hotkeyHandler ' + char)\n    if (char === '?') {\n      toggleOverviewPanel()\n    } else {\n      let handle = dataLockBox.retrieve({ entry: char })\n      if (!handle) {\n        const records = dataLockBox.overview()\n        records.some(record => {\n          if (record.match instanceof Array && record.match.includes(char)) {\n            handle = dataLockBox.retrieve({ entry: record.match })\n            //console.log(`handle found: ${handle.description}`)\n          }\n          return Boolean(handle)\n        })\n      }\n      return handle\n    }\n  }\n\n  /**\n   * Register a context to trigger a function when any barcode is encountered\n   * @param {object} props\n   */\n  const registerBarcode = function(props) {\n    delete props.char\n    if (!props.regex) {\n      props.regex = catchAllRegExp\n    }\n    if (registrationSanity(props)) {\n      registerMatch(props)\n      //console.log(`barcode registered: ${props.regex}`)\n      return props\n    }\n  }\n\n  /**\n   * Find the lengthiest RegExp for barcode\n   * @private\n   * @param {string} barcode\n   * @returns {RegExp}\n   */\n  const barcodeMatch = function(barcode) {\n    let regex = catchAllRegExp\n    const keys = dataLockBox.keys()\n\n    for (let key of keys) {\n      if (key instanceof RegExp && key.test(barcode)) {\n        // find the most complex RegExp\n        if (key.toString().length > regex.toString().length) {\n          regex = key\n        }\n      }\n    }\n    return regex\n  }\n\n  /**\n   * Find the right data for barcode\n   * @param {string} barcode\n   * @returns {object} data object\n   */\n  const barcodeHandler = function(barcode) {\n    const regex = barcodeMatch(barcode)\n    return dataLockBox.retrieve({ entry: regex })\n  }\n\n  /**\n   * Generate a list of active entries\n   * @returns {object}\n   */\n  const overviewJson = function() {\n    let handles = {}\n    let records = dataLockBox.overview()\n\n    // look for multiMatches\n    let matchRecords = new Object()\n    records.forEach(record => {\n      var peers = records.filter(\n        other =>\n          other.box.callback === record.box.callback &&\n          other.box.description === record.box.description,\n      )\n      if (peers.length > 1) {\n        var matches = peers.map(peer => peer.match)\n        matchRecords[matches] = 'box'\n      }\n    })\n\n    // add multiMatches as one record, remove seperate records\n    const multiMatches = Object.keys(matchRecords)\n    multiMatches.forEach(multiMatch => {\n      const multiMatchArray = multiMatch.split(',')\n      multiMatchArray.forEach((matchItem, matchIndex) => {\n        records = records.map(record => {\n          if (record && record.match === matchItem) {\n            if (!matchIndex) {\n              // replace first matchItem\n              record = {\n                ...record,\n                match: multiMatch.replace(/,(\\S)/g, ', $1'),\n              }\n            } else {\n              // remove rest of matchItemes\n              record = null\n            }\n          }\n          return record\n        })\n      })\n    })\n\n    records.forEach(record => {\n      if (record && record.box && typeof record.match === 'string') {\n        let toEndUser = {\n          match: record.match,\n          description: record.box.description,\n        }\n        handles.hotkeys = handles.hotkeys\n          ? handles.hotkeys.concat([toEndUser])\n          : [toEndUser]\n      }\n      if (record && record.box && record.match instanceof RegExp) {\n        let toEndUser = {\n          match: 'barcode', //record.match.toString(),\n          description: record.box.description,\n        }\n        handles.barcodes = handles.barcodes\n          ? handles.barcodes.concat([toEndUser])\n          : [toEndUser]\n      }\n    })\n    //console.log('overview:\\n' + JSON.stringify(handles))\n    return handles\n  }\n\n  /**\n   * Coerce a screen in the html - public toggle function\n   */\n  let toggleOverviewPanel = function() {\n    appendOverviewHtml()\n  }\n\n  /**\n   * Coerce a screen in the html - append function\n   * @private\n   */\n  const appendOverviewHtml = function() {\n    const handles = overviewJson()\n\n    // build\n    let svgString = `\n    <svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\"\n    \t viewBox=\"0 0 507.2 507.2\" style=\"enable-background:new 0 0 507.2 507.2;\" xml:space=\"preserve\">\n    <circle fill=\"#000000\" cx=\"253.6\" cy=\"253.6\" r=\"253.6\"/>\n    <path fill=\"#FFFFFF\" d=\"M373.6,309.6c11.2,11.2,11.2,30.4,0,41.6l-22.4,22.4c-11.2,11.2-30.4,11.2-41.6,0l-176-176\n    \tc-11.2-11.2-11.2-30.4,0-41.6l23.2-23.2c11.2-11.2,30.4-11.2,41.6,0L373.6,309.6z\"/>\n    <path fill=\"#FFFFFF\" d=\"M309.6,133.6c11.2-11.2,30.4-11.2,41.6,0l23.2,23.2c11.2,11.2,11.2,30.4,0,41.6L197.6,373.6\n    \tc-11.2,11.2-30.4,11.2-41.6,0l-22.4-22.4c-11.2-11.2-11.2-30.4,0-41.6L309.6,133.6z\"/>\n    </svg>\n    `\n    let htmlString = `<table>`\n    const writeMatches = function(prop) {\n      let str = `<thead><tr><th colspan=\"2\">${prop}</th><tr></thead><tbody>`\n      for (let item of handles[prop] || []) {\n        str += `<tr><th>${item.match}</th><td>${item.description}</td></tr>`\n      }\n      return str + `</tbody>`\n    }\n    if (handles.hotkeys) {\n      htmlString += writeMatches('hotkeys')\n    }\n    if (handles.barcodes) {\n      htmlString += writeMatches('barcodes')\n    }\n    if (!handles.hotkeys && !handles.barcodes) {\n      htmlString += writeMatches('no hotkeys or barcodes configured')\n    }\n\n    htmlString += `</table>`\n    let panel = document.createElement('chars-and-chuncks-panel')\n    panel.innerHTML = svgString + htmlString\n\n    // apply\n    dataLockBox.overlay()\n    document.body.appendChild(panel)\n    panel\n      .querySelector('table:first-of-type')\n      .addEventListener('click', removeOverviewHtml)\n    panel\n      .querySelector('svg:first-of-type')\n      .addEventListener('click', removeOverviewHtml)\n\n    // direct the toggle\n    toggleOverviewPanel = function() {\n      removeOverviewHtml()\n    }\n  }\n\n  /**\n   * Remove the open help-screen in the html\n   * @private\n   */\n  const removeOverviewHtml = function(event) {\n    const panel = document.querySelector('chars-and-chuncks-panel')\n    panel\n      .querySelector('table:first-of-type')\n      .removeEventListener('click', removeOverviewHtml)\n    panel\n      .querySelector('svg:first-of-type')\n      .removeEventListener('click', removeOverviewHtml)\n    panel.remove()\n    dataLockBox.revive()\n    toggleOverviewPanel = function() {\n      appendOverviewHtml()\n    }\n  }\n\n  /*\n   * Make object in context eligible for garbage collection\n   * @param {object} context\n   */\n  const cleanup = function(sanitisedProps) {\n    dataLockBox.cleanup(sanitisedProps.context)\n  }\n\n  return {\n    registerHotkey: function(props) {\n      const saneProps = registerHotkey(props)\n      return function() {\n        if (saneProps && saneProps.context) cleanup(saneProps)\n      }\n    },\n    registerHotkeys: function(propsList) {\n      const sanePropsList = registerHotkeys(propsList)\n      return function() {\n        sanePropsList.forEach(saneProps => {\n          if (saneProps && saneProps.context) cleanup(saneProps)\n        })\n      }\n    },\n    hotkeyHandler: hotkeyHandler,\n    registerBarcode: function(props) {\n      const saneProps = registerBarcode(props)\n      return function() {\n        if (saneProps && saneProps.context) cleanup(saneProps)\n      }\n    },\n    barcodeHandler: barcodeHandler,\n    overviewJson: overviewJson,\n    overviewPanel: toggleOverviewPanel,\n    reset: dataLockBox.reset,\n    overlay: dataLockBox.overlay,\n    revive: dataLockBox.revive,\n  }\n})()\n\nexport { collectionManagement }\n","import { collectionManagement } from './collectionManagement'\n\nconst charsAndChunksModule = (function() {\n  // Maximum time the barcode scanner takes to send the next character\n  let safeIntermission = 30\n  // General treshold to prevent accidental elbow-on-keyboard processing\n  let minimalBarcodeLength = 6\n\n  const allowedModifiers = ['Shift', 'Alt']\n  // Process variables\n  let streamTimeout = 0\n  let stream = []\n\n  const settleStream = function(event) {\n    // We only deal with single characters or barcodes.\n    let settle = stream.join('')\n    if (stream.length >= minimalBarcodeLength) {\n      //console.log(`handle as barcode: ${settle} (${stream.length})`)\n      let handle = collectionManagement.barcodeHandler(settle)\n      if (handle) {\n        handle.callback(settle)\n      }\n    } else if (stream.length === 1) {\n      //console.log(`handle as character: ${settle} (${stream.length})`)\n      if (event.ctrlKey) settle = `ctrl+${settle}`\n      let handle = collectionManagement.hotkeyHandler(settle)\n      if (handle) {\n        handle.callback(settle)\n      }\n    } else {\n      //console.log(`invalid stream length: ${stream.length} (${settle})`)\n    }\n    stream = []\n  }\n\n  const streamHandler = function(event) {\n    //console.log(`input: ${event.key}`)\n    if (streamTimeout) {\n      clearTimeout(streamTimeout)\n    }\n\n    // We expect our input can safely be processed; we leave entry with on-the-fly editing to form controls\n    const fromFormControl =\n      event.target.tagName === 'INPUT' ||\n      event.target.tagName === 'TEXTAREA' ||\n      event.target.tagName === 'SELECT'\n    if (fromFormControl) {\n      stream = []\n      return\n    }\n\n    // We expect our barcode scanner to send character by character.\n    const multiChar = event.key.length > 1\n    if (multiChar) {\n      // Do not wait for new characters\n      //console.log(`out of scope: '${event.key}' in stream: '${stream}'`)\n      if (stream.length && event.key === 'Enter') {\n        settleStream(event)\n        return\n      } else if (!allowedModifiers.includes(event.key)) {\n        // pageDown, Tab, Backspace, etc.\n        // Do not use previous characters also\n        stream = [event.key]\n        settleStream(event)\n        return\n      }\n      // With allowedModifiers we want to set a new timeout\n    } else {\n      // barcode characters pass here\n      stream.push(event.key)\n    }\n\n    streamTimeout = setTimeout(settleStream, safeIntermission, event)\n  }\n\n  window.addEventListener('keydown', streamHandler)\n\n  return {\n    publicAPI: {\n      hotkey: collectionManagement.registerHotkey,\n      hotkeys: collectionManagement.registerHotkeys,\n      barcode: collectionManagement.registerBarcode,\n      overview: collectionManagement.overviewJson,\n      help: collectionManagement.overviewPanel,\n      reset: collectionManagement.reset,\n      overlay: collectionManagement.overlay,\n      revive: collectionManagement.revive,\n    },\n    testAPI: {\n      hotkeyHandler: collectionManagement.hotkeyHandler,\n      barcodeHandler: collectionManagement.barcodeHandler,\n    },\n  }\n})()\n\nconst charsAndChunks = charsAndChunksModule.publicAPI\nconst charsAndTests = charsAndChunksModule.testAPI\n\nexport { charsAndChunks, charsAndTests }\n"],"names":["dataLockBox","LockBoxModel","this","lock","Map","box","WeakMap","data","stash","retrieve","props","has","entry","context","get","reset","store","OK","console","error","storageSanity","set","match","keys","overview","records","key","record","push","overlay","Object","assign","revive","length","pop","cleanup","forEach","matchyVal","undefined","delete","collectionManagement","catchAllRegExp","registrationSanity","matchOK","char","regex","RegExp","contextOK","document","querySelector","callbackOK","callback","descriptionOK","description","location","port","log","registerMatch","registerHotkey","Array","lastSanePropIfAny","lastProp","singleCharProps","overviewJson","handles","matchRecords","peers","filter","other","matches","map","peer","multiMatch","split","matchItem","matchIndex","replace","toEndUser","hotkeys","concat","barcodes","toggleOverviewPanel","appendOverviewHtml","htmlString","writeMatches","prop","str","item","panel","createElement","innerHTML","body","appendChild","addEventListener","removeOverviewHtml","event","removeEventListener","remove","sanitisedProps","saneProps","registerHotkeys","propsList","sanePropsList","refsList","refs","hotkeyHandler","handle","some","includes","Boolean","registerBarcode","barcodeHandler","barcode","test","toString","barcodeMatch","overviewPanel","allowedModifiers","streamTimeout","stream","settleStream","settle","join","ctrlKey","window","clearTimeout","target","tagName","setTimeout","publicAPI","hotkey","help","testAPI"],"mappings":"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"}